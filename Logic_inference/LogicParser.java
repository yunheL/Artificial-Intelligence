
import java.util.List;
import processing.core.PApplet;
import processing.data.XML;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;

// LogicParser.toXML(String logic) converts an input string of
// propositional logic into the xml parse tree that it returns

public class LogicParser implements ParseTreeListener {

	private XML xml;

	public static XML toXML(String logic)
	{				
		AntlrLexer lexer = new AntlrLexer(new ANTLRInputStream(logic));
		CommonTokenStream tokens = new CommonTokenStream(lexer);
		AntlrParser parser = new AntlrParser(tokens);
		parser.setBuildParseTree(true);
		LogicParser listener = new LogicParser();
		parser.addParseListener(listener);
		parser.r();
		return listener.xml;
	}

	public void exitR(AntlrParser.RContext ctx) 	
	{ 
		PApplet p = new PApplet();
		xml = p.parseXML("<logic></logic>");		
		createTreeXML(ctx,xml);
	}

	public void createTreeXML(ParseTree tree, XML xml)
	{
		// beautify antlr rule names
		String type = tree.getClass().getSimpleName();
		int trim = type.indexOf("Context");
		if(trim != -1) type = type.substring(0,trim).toLowerCase();
		// add parse tree branches
		if(	type.equals("bicondition") ||
				type.equals("condition") ||
				type.equals("or") ||
				type.equals("and") ||
				type.equals("not") )
			xml = xml.addChild(type);
		// add parse tree leaves
		else if( type.equals("proposition") )
			xml = xml.addChild(tree.getText());
		// recurse through all children
		for(int i=0;i<tree.getChildCount();i++)
			createTreeXML(tree.getChild(i),xml);
	}		
	
	// The following code was automatically generated by Antlr4, and
	// then condensed into this single class by Gary Dahl.  The g4 
	// file used to generate this code included the following rules:
	
	//	grammar Logic;
	//
	//	r : ( expr (NEWLINE|EOF) )* ;
	//
	//	expr : '(' expr ')'     # GROUP
	//	     | '!' expr         # NOT
	//	     | expr '&&' expr   # AND
	//	     | expr '||' expr   # OR
	//	     | expr '=>' expr   # CONDITION
	//	     | expr '<=>' expr  # BICONDITION
	//	     | PROP             # PROPOSITION
	//	     ;
	//
	//	NEWLINE : '\r'? '\n' ;
	//	PROP : ('a'..'z'|'A'..'Z')+ ;
	//	WS : [ \t\r\n]+ -> skip ;
	

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterR(AntlrParser.RContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterGROUP(AntlrParser.GROUPContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitGROUP(AntlrParser.GROUPContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterNOT(AntlrParser.NOTContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitNOT(AntlrParser.NOTContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterPROPOSITION(AntlrParser.PROPOSITIONContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitPROPOSITION(AntlrParser.PROPOSITIONContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterOR(AntlrParser.ORContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitOR(AntlrParser.ORContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterAND(AntlrParser.ANDContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitAND(AntlrParser.ANDContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterCONDITION(AntlrParser.CONDITIONContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitCONDITION(AntlrParser.CONDITIONContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterBICONDITION(AntlrParser.BICONDITIONContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitBICONDITION(AntlrParser.BICONDITIONContext ctx) { }

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void enterEveryRule(ParserRuleContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void exitEveryRule(ParserRuleContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void visitTerminal(TerminalNode node) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	public void visitErrorNode(ErrorNode node) { }

	// Generated from Logic.g4 by ANTLR 4.5
	public static class AntlrParser extends Parser {
		static { RuntimeMetaData.checkVersion("4.5", RuntimeMetaData.VERSION); }

		protected static final DFA[] _decisionToDFA;
		protected static final PredictionContextCache _sharedContextCache =
				new PredictionContextCache();
		public static final int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, NEWLINE=8, PROP=9, 
		WS=10;
		public static final int
		RULE_r = 0, RULE_expr = 1;
		public static final String[] ruleNames = {
				"r", "expr"
		};

		private static final String[] _LITERAL_NAMES = {
				null, "'('", "')'", "'!'", "'&&'", "'||'", "'=>'", "'<=>'"
		};
		private static final String[] _SYMBOLIC_NAMES = {
				null, null, null, null, null, null, null, null, "NEWLINE", "PROP", "WS"
		};
		public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

		/**
		 * @deprecated Use {@link #VOCABULARY} instead.
		 */
		@Deprecated
		public static final String[] tokenNames;
		static {
			tokenNames = new String[_SYMBOLIC_NAMES.length];
			for (int i = 0; i < tokenNames.length; i++) {
				tokenNames[i] = VOCABULARY.getLiteralName(i);
				if (tokenNames[i] == null) {
					tokenNames[i] = VOCABULARY.getSymbolicName(i);
				}

				if (tokenNames[i] == null) {
					tokenNames[i] = "<INVALID>";
				}
			}
		}

		@Override
		@Deprecated
		public String[] getTokenNames() {
			return tokenNames;
		}

		@Override

		public Vocabulary getVocabulary() {
			return VOCABULARY;
		}

		@Override
		public String getGrammarFileName() { return "Logic.g4"; }

		@Override
		public String[] getRuleNames() { return ruleNames; }

		@Override
		public String getSerializedATN() { return _serializedATN; }

		@Override
		public ATN getATN() { return _ATN; }

		public AntlrParser(TokenStream input) {
			super(input);
			_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
		}
		public static class RContext extends ParserRuleContext {
			public List<ExprContext> expr() {
				return getRuleContexts(ExprContext.class);
			}
			public ExprContext expr(int i) {
				return getRuleContext(ExprContext.class,i);
			}
			public List<TerminalNode> NEWLINE() { return getTokens(AntlrParser.NEWLINE); }
			public TerminalNode NEWLINE(int i) {
				return getToken(AntlrParser.NEWLINE, i);
			}
			public List<TerminalNode> EOF() { return getTokens(AntlrParser.EOF); }
			public TerminalNode EOF(int i) {
				return getToken(AntlrParser.EOF, i);
			}
			public RContext(ParserRuleContext parent, int invokingState) {
				super(parent, invokingState);
			}
			@Override public int getRuleIndex() { return RULE_r; }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterR(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitR(this);
			}
		}

		public final RContext r() throws RecognitionException {
			RContext _localctx = new RContext(_ctx, getState());
			enterRule(_localctx, 0, RULE_r);
			int _la;
			try {
				enterOuterAlt(_localctx, 1);
				{
					setState(9);
					_errHandler.sync(this);
					_la = _input.LA(1);
					while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << T__2) | (1L << PROP))) != 0)) {
						{
							{
								setState(4);
								expr(0);
								setState(5);
								_la = _input.LA(1);
								if ( !(_la==EOF || _la==NEWLINE) ) {
									_errHandler.recoverInline(this);
								} else {
									consume();
								}
							}
						}
						setState(11);
						_errHandler.sync(this);
						_la = _input.LA(1);
					}
				}
			}
			catch (RecognitionException re) {
				_localctx.exception = re;
				_errHandler.reportError(this, re);
				_errHandler.recover(this, re);
			}
			finally {
				exitRule();
			}
			return _localctx;
		}

		public static class ExprContext extends ParserRuleContext {
			public ExprContext(ParserRuleContext parent, int invokingState) {
				super(parent, invokingState);
			}
			@Override public int getRuleIndex() { return RULE_expr; }

			public ExprContext() { }
			public void copyFrom(ExprContext ctx) {
				super.copyFrom(ctx);
			}
		}
		public static class GROUPContext extends ExprContext {
			public ExprContext expr() {
				return getRuleContext(ExprContext.class,0);
			}
			public GROUPContext(ExprContext ctx) { copyFrom(ctx); }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterGROUP(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitGROUP(this);
			}
		}
		public static class NOTContext extends ExprContext {
			public ExprContext expr() {
				return getRuleContext(ExprContext.class,0);
			}
			public NOTContext(ExprContext ctx) { copyFrom(ctx); }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterNOT(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitNOT(this);
			}
		}
		public static class PROPOSITIONContext extends ExprContext {
			public TerminalNode PROP() { return getToken(AntlrParser.PROP, 0); }
			public PROPOSITIONContext(ExprContext ctx) { copyFrom(ctx); }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterPROPOSITION(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitPROPOSITION(this);
			}
		}
		public static class ORContext extends ExprContext {
			public List<ExprContext> expr() {
				return getRuleContexts(ExprContext.class);
			}
			public ExprContext expr(int i) {
				return getRuleContext(ExprContext.class,i);
			}
			public ORContext(ExprContext ctx) { copyFrom(ctx); }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterOR(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitOR(this);
			}
		}
		public static class ANDContext extends ExprContext {
			public List<ExprContext> expr() {
				return getRuleContexts(ExprContext.class);
			}
			public ExprContext expr(int i) {
				return getRuleContext(ExprContext.class,i);
			}
			public ANDContext(ExprContext ctx) { copyFrom(ctx); }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterAND(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitAND(this);
			}
		}
		public static class CONDITIONContext extends ExprContext {
			public List<ExprContext> expr() {
				return getRuleContexts(ExprContext.class);
			}
			public ExprContext expr(int i) {
				return getRuleContext(ExprContext.class,i);
			}
			public CONDITIONContext(ExprContext ctx) { copyFrom(ctx); }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterCONDITION(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitCONDITION(this);
			}
		}
		public static class BICONDITIONContext extends ExprContext {
			public List<ExprContext> expr() {
				return getRuleContexts(ExprContext.class);
			}
			public ExprContext expr(int i) {
				return getRuleContext(ExprContext.class,i);
			}
			public BICONDITIONContext(ExprContext ctx) { copyFrom(ctx); }
			@Override
			public void enterRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).enterBICONDITION(this);
			}
			@Override
			public void exitRule(ParseTreeListener listener) {
				if ( listener instanceof LogicParser ) ((LogicParser)listener).exitBICONDITION(this);
			}
		}

		public final ExprContext expr() throws RecognitionException {
			return expr(0);
		}

		private ExprContext expr(int _p) throws RecognitionException {
			ParserRuleContext _parentctx = _ctx;
			int _parentState = getState();
			ExprContext _localctx = new ExprContext(_ctx, _parentState);
			ExprContext _prevctx = _localctx;
			int _startState = 2;
			enterRecursionRule(_localctx, 2, RULE_expr, _p);
			try {
				int _alt;
				enterOuterAlt(_localctx, 1);
				{
					setState(20);
					switch (_input.LA(1)) {
					case T__2:
					{
						_localctx = new NOTContext(_localctx);
						_ctx = _localctx;
						_prevctx = _localctx;

						setState(13);
						match(T__2);
						setState(14);
						expr(6);
					}
					break;
					case T__0:
					{
						_localctx = new GROUPContext(_localctx);
						_ctx = _localctx;
						_prevctx = _localctx;
						setState(15);
						match(T__0);
						setState(16);
						expr(0);
						setState(17);
						match(T__1);
					}
					break;
					case PROP:
					{
						_localctx = new PROPOSITIONContext(_localctx);
						_ctx = _localctx;
						_prevctx = _localctx;
						setState(19);
						match(PROP);
					}
					break;
					default:
						throw new NoViableAltException(this);
					}
					_ctx.stop = _input.LT(-1);
					setState(36);
					_errHandler.sync(this);
					_alt = getInterpreter().adaptivePredict(_input,3,_ctx);
					while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							if ( _parseListeners!=null ) triggerExitRuleEvent();
							_prevctx = _localctx;
							{
								setState(34);
								switch ( getInterpreter().adaptivePredict(_input,2,_ctx) ) {
								case 1:
								{
									_localctx = new ANDContext(new ExprContext(_parentctx, _parentState));
									pushNewRecursionContext(_localctx, _startState, RULE_expr);
									setState(22);
									if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, "precpred(_ctx, 5)");
									setState(23);
									match(T__3);
									setState(24);
									expr(6);
								}
								break;
								case 2:
								{
									_localctx = new ORContext(new ExprContext(_parentctx, _parentState));
									pushNewRecursionContext(_localctx, _startState, RULE_expr);
									setState(25);
									if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
									setState(26);
									match(T__4);
									setState(27);
									expr(5);
								}
								break;
								case 3:
								{
									_localctx = new CONDITIONContext(new ExprContext(_parentctx, _parentState));
									pushNewRecursionContext(_localctx, _startState, RULE_expr);
									setState(28);
									if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
									setState(29);
									match(T__5);
									setState(30);
									expr(4);
								}
								break;
								case 4:
								{
									_localctx = new BICONDITIONContext(new ExprContext(_parentctx, _parentState));
									pushNewRecursionContext(_localctx, _startState, RULE_expr);
									setState(31);
									if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
									setState(32);
									match(T__6);
									setState(33);
									expr(3);
								}
								break;
								}
							} 
						}
						setState(38);
						_errHandler.sync(this);
						_alt = getInterpreter().adaptivePredict(_input,3,_ctx);
					}
				}
			}
			catch (RecognitionException re) {
				_localctx.exception = re;
				_errHandler.reportError(this, re);
				_errHandler.recover(this, re);
			}
			finally {
				unrollRecursionContexts(_parentctx);
			}
			return _localctx;
		}

		public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
			switch (ruleIndex) {
			case 1:
				return expr_sempred((ExprContext)_localctx, predIndex);
			}
			return true;
		}
		private boolean expr_sempred(ExprContext _localctx, int predIndex) {
			switch (predIndex) {
			case 0:
				return precpred(_ctx, 5);
			case 1:
				return precpred(_ctx, 4);
			case 2:
				return precpred(_ctx, 3);
			case 3:
				return precpred(_ctx, 2);
			}
			return true;
		}

		public static final String _serializedATN =
				"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3\f*\4\2\t\2\4\3\t"+
						"\3\3\2\3\2\3\2\7\2\n\n\2\f\2\16\2\r\13\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3"+
						"\3\5\3\27\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\7\3%\n\3"+
						"\f\3\16\3(\13\3\3\3\2\3\4\4\2\4\2\3\3\3\n\n.\2\13\3\2\2\2\4\26\3\2\2\2"+
						"\6\7\5\4\3\2\7\b\t\2\2\2\b\n\3\2\2\2\t\6\3\2\2\2\n\r\3\2\2\2\13\t\3\2"+
						"\2\2\13\f\3\2\2\2\f\3\3\2\2\2\r\13\3\2\2\2\16\17\b\3\1\2\17\20\7\5\2\2"+
						"\20\27\5\4\3\b\21\22\7\3\2\2\22\23\5\4\3\2\23\24\7\4\2\2\24\27\3\2\2\2"+
						"\25\27\7\13\2\2\26\16\3\2\2\2\26\21\3\2\2\2\26\25\3\2\2\2\27&\3\2\2\2"+
						"\30\31\f\7\2\2\31\32\7\6\2\2\32%\5\4\3\b\33\34\f\6\2\2\34\35\7\7\2\2\35"+
						"%\5\4\3\7\36\37\f\5\2\2\37 \7\b\2\2 %\5\4\3\6!\"\f\4\2\2\"#\7\t\2\2#%"+
						"\5\4\3\5$\30\3\2\2\2$\33\3\2\2\2$\36\3\2\2\2$!\3\2\2\2%(\3\2\2\2&$\3\2"+
						"\2\2&\'\3\2\2\2\'\5\3\2\2\2(&\3\2\2\2\6\13\26$&";
		public static final ATN _ATN =
				new ATNDeserializer().deserialize(_serializedATN.toCharArray());
		static {
			_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
			for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
				_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
			}
		}
	}	 

	// Generated from Logic.g4 by ANTLR 4.5
	@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})
	public static class AntlrLexer extends Lexer {
		static { RuntimeMetaData.checkVersion("4.5", RuntimeMetaData.VERSION); }

		protected static final DFA[] _decisionToDFA;
		protected static final PredictionContextCache _sharedContextCache =
				new PredictionContextCache();
		public static final int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, NEWLINE=8, PROP=9, 
		WS=10;
		public static String[] modeNames = {
				"DEFAULT_MODE"
		};

		public static final String[] ruleNames = {
				"T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "NEWLINE", "PROP", 
				"WS"
		};

		private static final String[] _LITERAL_NAMES = {
				null, "'('", "')'", "'!'", "'&&'", "'||'", "'=>'", "'<=>'"
		};
		private static final String[] _SYMBOLIC_NAMES = {
				null, null, null, null, null, null, null, null, "NEWLINE", "PROP", "WS"
		};
		public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

		/**
		 * @deprecated Use {@link #VOCABULARY} instead.
		 */
		@Deprecated
		public static final String[] tokenNames;
		static {
			tokenNames = new String[_SYMBOLIC_NAMES.length];
			for (int i = 0; i < tokenNames.length; i++) {
				tokenNames[i] = VOCABULARY.getLiteralName(i);
				if (tokenNames[i] == null) {
					tokenNames[i] = VOCABULARY.getSymbolicName(i);
				}

				if (tokenNames[i] == null) {
					tokenNames[i] = "<INVALID>";
				}
			}
		}

		@Override
		@Deprecated
		public String[] getTokenNames() {
			return tokenNames;
		}

		@Override

		public Vocabulary getVocabulary() {
			return VOCABULARY;
		}


		public AntlrLexer(CharStream input) {
			super(input);
			_interp = new LexerATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
		}

		@Override
		public String getGrammarFileName() { return "Logic.g4"; }

		@Override
		public String[] getRuleNames() { return ruleNames; }

		@Override
		public String getSerializedATN() { return _serializedATN; }

		@Override
		public String[] getModeNames() { return modeNames; }

		@Override
		public ATN getATN() { return _ATN; }

		public static final String _serializedATN =
				"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\2\f;\b\1\4\2\t\2\4"+
						"\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t"+
						"\13\3\2\3\2\3\3\3\3\3\4\3\4\3\5\3\5\3\5\3\6\3\6\3\6\3\7\3\7\3\7\3\b\3"+
						"\b\3\b\3\b\3\t\5\t,\n\t\3\t\3\t\3\n\6\n\61\n\n\r\n\16\n\62\3\13\6\13\66"+
						"\n\13\r\13\16\13\67\3\13\3\13\2\2\f\3\3\5\4\7\5\t\6\13\7\r\b\17\t\21\n"+
						"\23\13\25\f\3\2\4\4\2C\\c|\5\2\13\f\17\17\"\"=\2\3\3\2\2\2\2\5\3\2\2\2"+
						"\2\7\3\2\2\2\2\t\3\2\2\2\2\13\3\2\2\2\2\r\3\2\2\2\2\17\3\2\2\2\2\21\3"+
						"\2\2\2\2\23\3\2\2\2\2\25\3\2\2\2\3\27\3\2\2\2\5\31\3\2\2\2\7\33\3\2\2"+
						"\2\t\35\3\2\2\2\13 \3\2\2\2\r#\3\2\2\2\17&\3\2\2\2\21+\3\2\2\2\23\60\3"+
						"\2\2\2\25\65\3\2\2\2\27\30\7*\2\2\30\4\3\2\2\2\31\32\7+\2\2\32\6\3\2\2"+
						"\2\33\34\7#\2\2\34\b\3\2\2\2\35\36\7(\2\2\36\37\7(\2\2\37\n\3\2\2\2 !"+
						"\7~\2\2!\"\7~\2\2\"\f\3\2\2\2#$\7?\2\2$%\7@\2\2%\16\3\2\2\2&\'\7>\2\2"+
						"\'(\7?\2\2()\7@\2\2)\20\3\2\2\2*,\7\17\2\2+*\3\2\2\2+,\3\2\2\2,-\3\2\2"+
						"\2-.\7\f\2\2.\22\3\2\2\2/\61\t\2\2\2\60/\3\2\2\2\61\62\3\2\2\2\62\60\3"+
						"\2\2\2\62\63\3\2\2\2\63\24\3\2\2\2\64\66\t\3\2\2\65\64\3\2\2\2\66\67\3"+
						"\2\2\2\67\65\3\2\2\2\678\3\2\2\289\3\2\2\29:\b\13\2\2:\26\3\2\2\2\6\2"+
						"+\62\67\3\b\2\2";
		public static final ATN _ATN =
				new ATNDeserializer().deserialize(_serializedATN.toCharArray());
		static {
			_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
			for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
				_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
			}
		}
	}
}