//Tested by Yunhe. Passed on 1/7/2016
//Question credit to Google Interview Practice
//Author: Yunhe Liu <liu348@wisc.edu>
package leetCodePractice;

/*
 * This class is supposed to work as:
 * Returning the index of one of the existing equilibrium point in O(N)
 * Time complexity
 * Defining a equilibrium point:
 * Given a integer array with length N. If there is a
 * zero-based index P such that the sum of the elements[0..P-1]
 * equals to the sum of the elements [P+1, N-1], then we call
 * P a equilibrium point. 
 * For example:
 * Given integer array {1,2,3,4,3,2,1}
 * index 3 (element = 4) would be a equilibrium point 
 * 
 * Note, when P = 0 or P = N-1, we define
 * one the sums as 0
 * For example:
 * Given integer array {1, -1, 1}
 * index 0 would be a equilibrium point.
 * 
 * Worst-case time complexity O(N)
 */
public class equilibriumPoint {

	/*
	 * This method provides 6 test cases and expected result for
	 * the solution.
	 */
	public static void main(String[] args) {
		
		int passCount = 0;
		int failCount = 0;

		int[] A = new int[]{-1, 3, -4, 5, 1, -6, 2, 1};
		int[] A1 = new int[]{};
		int[] A2 = new int[]{0,0,0,0,0};
		int[] A3 = new int[]{1,2,3,2,1};
		int[] A4 = new int[]{4,3,4,3,4,3,4,3,4};
		int[] A5 = new int[]{6,5,1,5,6};
		
		int[] expected = new int[]{1,-1,0,2,4,2};
		int[] result = new int[]{solution(A), solution(A1), solution(A2),
				solution(A3),solution(A4),solution(A5)};
		int i = 0;
		for(; i<result.length; i++)
		{
			if(result[i] == expected[i])
			{
				System.out.print("Passed! ");
				passCount++;
			}
			else
			{
				System.out.print("Failed! ");
				failCount++;
			}
			System.out.println("Expected: " + expected[i] 
					+ " result = " + result[i]);
		}
		
		System.out.println("=====Test Summary=====");
		if(passCount == result.length)
			System.out.println("Congrats! All passed! ^_^");
		else
			System.out.println("Oops! Some case did not pass! >_<");
		
		System.out.print("Passed: " + passCount + " Failed: " + failCount);
		
	}
	
	/*
	 * Given an int array, this method calculates and returns
	 * the sum of all its elements.
	 */
	public static int sumIntArray(int[] A) {
		int sum = 0;
		
		int i = 0;
		for(; i< A.length; i++)
		{
			sum = sum + A[i];
		}
		
		return sum;
		
	}
	
	/*
	 * O(N) Solution
	 */
	
	public static int solution(int[] A) {

		int sum = sumIntArray(A);
		int currSum = 0;

		int i = 0;
		for(;i<A.length;i++)
		{
			currSum = currSum + A[i];
			
			//if sum-A[i] is not a even number, then the
			//sum of elements on the left and right of A[i]
			//can not be equal 
			//i.e. A[i] cannot be equilibrium point
			//Doing this check is essential and beneficial:
			//Essential: Aviod discrepancy generated by integer
			//arithmetic, e.g. 3/2 = 1
			//Beneficial: speed up by not checking unnecessary
			//elements.
			if((sum-A[i])%2 == 0)
			{
				//judge using definition of equilibrium point
				if((currSum - A[i]) == ((sum-A[i])/2))
				{
					return i;
				}
			}
		}	
		return -1;
    }
    
	/*
	 * O(N^2) Solution
	 */
	/*
	public static int solution(int[] A) {

        int i = 0;
        int sumLeft = 0;
        int sumRight = 0;
        int j = 0;
		
        for(i=0;i<A.length;i++)
		{
			sumLeft = 0;
			sumRight = 0;
        	//handle special case
			if(i == 0)
			{
				j = i;
				sumLeft = 0;
				for(j = 1; j<A.length; j++)
				{
					sumRight = sumRight + A[j];
				}
			}
			else if(j == A.length-1)
			{
				sumRight = 0;
				for(j = 0; j<A.length-1; j++)
				{
					sumLeft = sumLeft + A[j];
				}
			}
			else
			{
				//calculate sumLeft
				for(j = 0; j<i; j++)
				{
					sumLeft = sumLeft + A[j];
				}
				//calculate sumRight
				for(j = i+1; j<A.length; j++)
				{
					sumRight = sumRight + A[j];
				}
			}

			if(sumRight == sumLeft)
			{
				return i;
			}
		}

		return -1;
    }
    */
}